#!/usr/bin/env python3

"""Markdown Tool
"""

import argparse
import re
import sys
import shutil
import os
from collections import OrderedDict  # 用于保持插入顺序
import panflute as pf


# 正则匹配：行首可选空格 + ![[ + 内容 + ]] + 可选空格 + 行尾
markdown_include_pattern = re.compile(r'^(\s*)!\[\[([^]]+)\]\]\s*$')


def process_expansion(filepath):
    """Processing file expansion.

    Args:
        filepath: str, Markdown document file path

    Returns:
        (stdout): processed document text
    """

    with open(filepath, 'r', encoding='utf-8') as f:
        for line in f:
            match = markdown_include_pattern.match(line)

            if match:
                indentation = match.group(1)
                subdoc_path = match.group(2).strip()

                with open(subdoc_path, 'r', encoding='utf-8') as subdoc:
                    for include_line in subdoc:
                        print(f"{indentation}{include_line}", end="")

                print("")  # 输出空行
            else:
                print(line, end="")


def process_markdown_depends(dir):
    """Generating dependency rules.

    Args:
        dir: str, directory including markdown files(.markdown)

    Returns:
        (stdout): the dependencies in the form of 'target: dependencies'  
    """

    print("# Nested markdowns")

    for root, _, files in os.walk(dir):
        for file in files:
            if not file.endswith('.markdown'):
                continue

            filepath = os.path.join(root, file)

            # 计算相对路径并转换为目标文件名：xxx.md
            rel_path = os.path.normpath(os.path.relpath(filepath, dir))
            target = rel_path[:-9] + '.md'  # 去除 .markdown，添加 .md

            # 收集唯一嵌入文件（保持第一次出现的顺序）
            depends = OrderedDict()

            with open(filepath, 'r', encoding='utf-8') as f:
                for line in f:
                    match = markdown_include_pattern.match(line)
                    if match:
                        subdoc_path = match.group(2).strip()  # 去除内容内首尾空格
                        if subdoc_path and subdoc_path not in depends:
                            subdoc_path_norm = os.path.normpath(subdoc_path)
                            depends[subdoc_path_norm] = None

            if depends:
                print(f"{target}: {' '.join(depends.keys())}")


def process_image_depends(dir):
    """Generating image dependency rules.

    Args:
        dir: str, directory including markdown files(.markdown)

    Returns:
        (stdout): the dependencies in the form of 'target: dependencies'  
    """

    print("# Nested images")

    # 排除网络图片（即 URL 形式的图片），只提取 本地文件路径的图片文件名，
    # 你可以在判断 Image 元素的 url 时，先检测它是否为 本地路径
    # （而非以 http: //、https: // 等开头的网络链接）
    URL_PATTERN = re.compile(r'^https?://|^//', re.IGNORECASE)

    # 查找所有图片元素
    def action(elem, doc):
        if isinstance(elem, pf.Image):
            # 判断是否为本地路径（非网络 URL）
            if (not URL_PATTERN.match(elem.url)):
                # 注意：这里需要一种方式把数据传出去
                url_norm = os.path.normpath(elem.url)
                doc.depends[url_norm] = None

    for root, _, files in os.walk(dir):
        for file in files:
            if not file.endswith('.markdown'):
                continue

            filepath = os.path.join(root, file)

            # 计算相对路径并转换为目标文件名：xxx.md
            rel_path = os.path.normpath(os.path.relpath(filepath, dir))
            target = rel_path[:-9] + '.md'  # 去除 .markdown，添加 .md

            # 直接读取文件并转换为 panflute 能够处理的 doc 对象
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()

                # 将 markdown 文本转换为抽象语法树 (AST)
                doc = pf.convert_text(
                    content, input_format='markdown', standalone=True)

                # 传递路径给 action
                doc.filepath = filepath

                # 给 doc 对象临时挂载一个属性来存储结果
                # 收集唯一嵌入文件（保持第一次出现的顺序）
                doc.depends = OrderedDict()

                # 对文档应用 action
                doc.walk(action)

                if doc.depends:
                    print(f"{target}: {' '.join(doc.depends.keys())}")


def process_depends(dir):
    """Generating nested markdown and image dependency rules.

    Args:
        dir: str, directory including markdown files(.markdown)

    Returns:
        (stdout): the dependencies in the form of 'target: dependencies'  
    """

    process_markdown_depends(dir)
    process_image_depends(dir)


def process_init(target_dir, article=False, overwrite=False):
    """Creating a project from a template/boilerplate.

    Args:
        target_dir: str, directory name
        article: bool, create an article if true, else book
        overwrite: bool, overwrite while file existing

    Returns:
        None
    """

    if article:
        source_dir = os.path.expanduser(
            '~/.local/share/pandoc/boilerplate/article')
    else:
        source_dir = os.path.expanduser(
            '~/.local/share/pandoc/boilerplate/book')

    if not os.path.isdir(source_dir):
        print(
            f"Error: The source directory does not exist or is not a directory: {source_dir}.")
        return

    if not os.path.exists(target_dir):
        os.makedirs(target_dir)

    for root, dirs, files in os.walk(source_dir):
        # 计算相对路径
        rel_path = os.path.relpath(root, source_dir)
        dst_path = target_dir if rel_path == '.' else os.path.join(
            target_dir, rel_path)

        # 构建目标子目录(如果不存在)
        os.makedirs(dst_path, exist_ok=True)

        # 复制文件
        for file in files:
            src_file = os.path.join(root, file)
            dst_file = os.path.join(dst_path, file)

            if os.path.exists(dst_file) and not overwrite:
                # 文件已存在，询问是否覆盖
                response = input(
                    f"The file already exists: {dst_file}.\nDo you want to overwrite it? (y/N): ").strip().lower()
                if response != 'y':
                    print(f"Skipped: {dst_file}")
                    continue

            # 执行拷贝（保留元数据）
            shutil.copy2(src_file, dst_file)
            print(f"Copied: {src_file} -> {dst_file}")


if __name__ == "__main__":
    try:
        parser = argparse.ArgumentParser(
            prog="mdtool",
            description="Markdown Processing Tool",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog="""
example:
  mdtool init [target_dir]  # default dir: .
  mdtool init [target_dir] -y  # overwrite
  mdtool init [target_dir] -a  # create an article
  mdtool depend input.md 
  mdtool expand input.md
"""
        )

        # 添加版本参数
        # %(prog)s 是一个占位符，会自动替换为你的文件名
        parser.add_argument(
            '-v', '--version',
            action='version',
            version='%(prog)s 0.2.0'
        )

        subparsers = parser.add_subparsers(
            # title="note",
            # description="subcommands implement different functions",
            dest="command",  # 存储子命令名称的属性名
            help="Description",  # 附加帮助信息
            metavar="Command",  # 帮助信息中的占位符
            required=True,  # 是否必须提供子命令 (Python 3.7+)
        )

        # ------------------- init (-i) -------------------
        p_i = subparsers.add_parser(
            "init",
            aliases=["i"],
            help="create a project from a boilerplate"
        )
        p_i.add_argument("dir", nargs="?", default=".",
                         help="destination directory(default: '.')")
        p_i.add_argument('-a', '--article', action='store_true',
                         help='Overwrite')  # default: False
        p_i.add_argument('-y', '--yes', action='store_true',
                         help='Overwrite')  # default: False

        p_i.set_defaults(func=lambda args: process_init(
            args.dir, article=args.article, overwrite=args.yes))

        # ------------------- depend (-d) -------------------
        p_d = subparsers.add_parser(
            "depend",
            aliases=["d"],
            help="generate nested markdown and image dependencies rules"
        )
        p_d.add_argument("dir", nargs="?", default=".",
                         help="directory of .markdown files(default: '.')")

        p_d.set_defaults(func=lambda args: process_depends(args.dir))

        # ------------------- expand (-e) -------------------
        p_e = subparsers.add_parser(
            "expand",
            aliases=["e"],
            help="process markdown expansion"
        )
        p_e.add_argument("file", help=".markdown file to be processed")

        p_e.set_defaults(func=lambda args: process_expansion(args.file))

        # 解析并执行
        args = parser.parse_args()
        args.func(args)

    except Exception as e:
        print(e, file=sys.stderr)
